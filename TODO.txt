
1. Реализовать быстрый алгоритм с помощью CircularBuffer из https://github.com/grinya007/2q
    - использовать циклический список
    - использовать предварительное создание списка размером $size
2. Реализовать быстрый алгоритм на C и C++ с использованием XS и Panda::XS

+1. Добавить поддержку List::DoubleLinked 0.005 (версия в /home/theathlete/work/job/my_development/perl/modules/list-doublelinked)
+2. Заменяем функцию move_node_to_head на splice
+3. Заменяем функцию remove_node_by_key на erase
+4. Прибраться в папке - скрипты либо перенести в bin/ либо реализовать как тесты в папке t/
5. Скрипты преобразовать к List::DoubleLinked версии 0.005 с учетом splice
6. Реализовать List::DoubleLinked на основе массивов и без итераторов (для скорости), см. Cache::TwoQ::CircularBuffer
7. В конструкторе заменить прием %args на $size и в объекте (bless) передавать (size => $size)
8. Доработка скриптов:
  - разделить скрипты на тест работы со связными списками и работы с кэшем LRU
  - перевести скрипты на использование List::DoubleLinked 0.005 (версия в /home/theathlete/work/job/my_development/perl/modules/list-doublelinked)
9. Подумать над удалением узла в списке - удалять ноду или удалять итератор. Удаление ноды быстрее

Сейчас:
1. Почистить код варианта с итераторами
2. Реализовать циклический список на базе List::DoubleLinked и предварительно создавать $size узлов
3. Реализовать на базе циклического списка CircularBuffer из примера кэша Cache::TwoQ

Варианты реализации алгоритма LRU:

1) сейчас: 
- на базе List::DoubleLinked (двусвязный список на базе хэшей); 
- узлы создаются по мере занесения данных в кэш (set)
- при попадании кэша (get), мы перемещаем узел (splice) в голову списка (если он не находится в голове)
- реализовано "протухание" ключа по времени

2) варианты реализации:
вариант 1
    - на базе List::DoubleLinked, реализовать циклический список по аналогии с Cache::TwoQ::CircularBuffer, 
    предварительно создавать пустые узлы с количеством равным $size;

вариант 2
    - использовать Cache::TwoQ::CircularBuffer - с обнулением, а не удалением узлов, как в примере алгоритма Cache::TwoQ

вариант 3
    - реализовать вариант 1 на C++, с использованием list, map, сделать биндинг с помощью Panda::XS

вариант 4
    - реализовать вариант 2 на C++, написать свой циклический список, сделать биндинг с помощью Panda::XS

вариант 5
    - реализовать варианты 1, 2 на C, написать свой циклический список, сделать биндинг с помощью XS

